<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- $Id$ -->
<!-- original version: 1.13 -->

 <sect1 condition="supports-tftp" id="install-tftp">
 <title>Preparando os arquivos para inicialização via rede usando TFTP</title>
<para>

Caso sua máquina esteja conectada a uma rede de área local, você poderá 
ser capaz de inicia-la através da rede a partir de outra máquina 
usando o servidor TFTP. Se tem a intenção de iniciar o sistema
de instalação para outra arquitetura, os arquivos de inicialização
precisarão ser colocados em localizações específicas da máquina e 
a máquina configurada para suportar inicialização em sua máquina 
específica.

</para><para>
Você precisará configurar um servidor TFTP e para máquinas CATS um 
servidor BOOTP
<phrase condition="supports-rarp">, ou um servidor RARP</phrase>
<phrase condition="supports-dhcp">, ou um servidor DHCP</phrase>.

</para><para>

<phrase condition="supports-rarp">O Reverse Address Resolution Protocol (RARP) é
o único método para dizer aos clientes qual endereço IP usar para si mesmo. 
Outro método é usar o protocolo BOOTP. </phrase>

<phrase condition="supports-bootp">O BOOTP é um protocolo IP que informa
um computador de seu endereço IP e onde na rede será obtida a imagem de
inicialização. </phrase>

<phrase arch="m68k"> Outra alternativa ainda existe nos sistemas
VMEbus: o endereço IP pode ser manualmente configurado na ROM de
inicialização. </phrase>

<phrase condition="supports-dhcp">O DHCP (Dynamic Host Configuration
Protocol) é uma extensão mais flexível, compatível com versões mais
antigas do BOOTP. Alguns sistemas somente podem ser configurados via
DHCP. </phrase>

</para><para arch="powerpc">

Para o PowerPC, se tiver uma máquina Power Macintosh NewWorld, 
será uma boa idéia de usar o DHCP ao invés do BOOTP. Algumas das 
últimas máquinas sã incapazes de inicializar usando o BOOTP.

</para><para arch="alpha"> 

Ao contrário do Open Firmware encontrado em máquinas Sparc e PowerPC, 
o console SRM <emphasis>não</emphasis> usará RARP para obter seu 
endereço IP, e então você deverá usar o BOOTP para inicializar via 
rede em seu Alpha. Você também poderá entrar com a configuração IP de suas
interfaces de rede diretamente no console SRM.

<footnote>
<para>

Os sistemas Alpha também podem ser inicializados via rede usando o 
DECNet MOP (Maintenance Operations Protocol), mas isto nao será 
discutido aqui. Presumivelmente, seu 
operador local do OpenVMS estará satisfeito em ajuda-lo se você 
tiver que esquentar a cabeça para usar o MOP para inicializar o 
Linux em seu Alpha.

</para>
</footnote></para><para arch="hppa"> 

Algumas máquinas HPPA antigas (e.g. 715/75) usarão o RBOOTD ao invés
do BOOTP. Um pacote RBOOTD está disponível na página internet
parisc-linux.

</para><para>

O protocolo Trivial File Transfer Protocol (TFTP) é usado para servidor
uma imagem de inicialização ao cliente. Teoricamente, qualquer 
servidor, em qualquer plataforma que implementa estes protocolos poderá
ser usados. Nos exemplos desta seção, nós mostraremos comando para
o SunOS 4.x, SunOS 5.x (a.k.a. Solaris), e para o GNU/Linux.

</para>

&tftp-rarp.xml;
&tftp-bootp.xml;
&tftp-dhcp.xml;

  <sect2 id="tftpd">
  <title>Ativando o servidor TFTP</title>
<para>

Para ter o servidor TFTP pronto, você terá primeiro que ter certeza
que o <command>tftpd</command> está ativado. Ele normalmente é ativado
tendo a seguinte linha no seu arquivo <filename>/etc/inetd.conf</filename>:

<informalexample><screen>

tftp dgram udp wait root /usr/sbin/tcpd in.tftpd /tftpboot

</screen></informalexample>

Olhe neste arquivo e lembre-se do diretório que é usado como 
argumento para o <command>in.tftpd</command>; você irá precisa dele
mais abaixo. O argumento <userinput>-l</userinput> permite que 
alguns tipos de versões do <command>in.tftpd</command> registrem
todas as requisições para os logs do sistema; isto é mais útil para 
diagnosticar erros de inicialização. Se você tiver que mudar o
<filename>/etc/inetd.conf</filename>, você terá que notificar o 
processo em execução <command>inetd</command> de que o arquivo foi 
modificado.
Em máquinas Debian, execute <userinput>/etc/init.d/inetd
reload</userinput> (para a potato/2.2 e sistemas mais novos use
<userinput>/etc/init.d/inetd reload</userinput>); em outras máquinas,
encontre o ID do processo do <command>inetd</command> e execute o 
comando <userinput>kill -HUP <replaceable>inetd-pid</replaceable></userinput>.

</para><para arch="i386">

Para usar o método Pre-boot Execution Environment (PXE) na 
inicialização TFTP, você somente precisará de um servidor TFTP
com o suporte a <userinput>tsize</userinput>. Em um servidor 
&debian; o <command>tftp-hpa</command> se qualifica.

</para><para arch="mips">

Caso seu servidor TFTP seja uma máquina GNU/Linux rodando 
o 2.4.x você precisará configurar o seguinte em seu servidor:

<informalexample><screen>

echo 1 > /proc/sys/net/ipv4/ip_no_pmtu_disc

</screen></informalexample>

para desligar o discovery de caminho MTU, caso contrário
o PROM do Indy não poderá baixar o kernel. Além disso, tenha 
certeza que os pacotes TFTP são enviados de uma porta de origem
que não seja maior que 32767 ou o download irá parar após o 
primeiro pacote. Novamente o Linux 2.4.x causando bugs na PROM 
você poderá evitar isto fazendo

<informalexample><screen>

echo "2048 32767" > /proc/sys/net/ipv4/ip_local_port_range

</screen></informalexample>

para ajustar a faixa de portas de origem que o servidor TFTP
do Linux utilizará.

</para>
  </sect2>

  <sect2 id="tftp-images">
  <title>Mover as imagens TFTp para o Local</title>
<para>

Como próximo passo, coloque a imagem de inicialização TFTP
que precisa, como encontrada no
<xref linkend="where-files"/> no diretório de imagens de inicialização
do <command>tftpd</command>. Geralmente este diretório será
<filename>/tftpboot</filename>. Você tera que fazer um link
deste arquivo para o arquivo que o <command>tftpd</command> usará
para inicializar em cliente em particular. Infelizmente, o nome do 
arquivo é determinado pelo client e TFTP e não existem padrões
rígidos.

</para><para arch="powerpc">

Em máquinas Power Macintosh NewWorld, você precisará configurar
o gerenciador de partida <command>yaboot</command> 
como a imagem de inicialização do TFTP.
O <command>Yaboot</command> então copiará as imagens de kernel e disco 
em RAM via TFTP. Para a inicialização via rede, use o
<filename>yaboot-netboot.conf</filename>. Apenas renomeie este arquivo
para <filename>yaboot.conf</filename> no diretório do TFTP.

</para><para arch="not-powerpc">

Freqüentemente, o arquivo que o cliente TFTP irá procurar é
<replaceable>client-ip-in-hexclient-architecture</replaceable>. Para 
computar <replaceable>client-ip-in-hex</replaceable>, pegue cada 
byte do endereço IP do cliente e transforme-o em notação hexadecimal. 
Se tiver uma máquina por perto com o programa <command>bc</command>,
você poderá usa-lo. Primeiro digite o comando <userinput>obase=16</userinput>
para ajustar a base para hex, então entre com componentes individuais
do IP do cliente um de cada vez. Como em
<replaceable>client-arquitetura</replaceable>, tente alguns valores.

</para><para arch="i386">

Para a inicialização usando o PXE, você poderá usar o gerenciador
de inicialização incluído com o <classname>syslinux</classname>: 
<filename>pxelinux.0</filename>. O gerenciador de partida deverá 
ser copiado na pasta <filename>/tftpboot</filename>. Então crie um 
subdiretório dentro de <filename>/tftpboot</filename> com o nome
<filename>/tftpboot/pxelinux.cfg</filename> e dentro daquele 
diretório crie um arquivo texto chamado <filename>default</filename>. 
Aqui está um exemplo do conteúdo do arquivo <filename>default</filename>:

<informalexample><screen>

default lanlinux
prompt 1

label lanlinux
  kernel tftpboot.img
  append load initrd=root.bin devfs=nomount

</screen></informalexample>

<userinput>devfs=nomount</userinput> é importante, porque
sem ele você poderá ter problemas durante a montagem do sistema 
de arquivos root.bin assim que o kernel inicializar.

</para><para arch="i386">

Finalmente, copie o arquivo <filename>tftpboot.img</filename> e
<filename>root.bin</filename> do arquivo ftp da Debian para a 
pasta <filename>/tftpboot</filename>, onde o gerenciador de partida
procurará por eles.

</para>


   <sect3 arch="mipsel">
   <title>Imagens TFTP do DECstation</title>
<para>

Para as DECstations, existem arquivos tftpimage para cada 
sub-arquitetura. que contém ambos os kernels e o programa de 
instalação em um arquivo. A convenção de nomes é 
tftpimage-<replaceable>subarchitecture</replaceable> ou
tftpimage-<replaceable>subarchitecture</replaceable>.gz. Se a imagem
tftpimage estiver compactada com gzip (o nome termina com .gz), você 
precisa descompacta-la primeiro com <userinput>gunzip
tftpimage-<replaceable>subarchitecture</replaceable>.gz</userinput>,
como máquinas DECstations não podem compactar arquivos usando o TFTP. 
Copie o arquivo tftpimage que deseja usar para
<userinput>/tftpboot/tftpboot.img</userinput> caso você utilize o 
exemplo BOOTP/DHCP descritos acima.

</para><para>

A firmware do DECstation é inicializada pelo TFTP com o comando 
<userinput>boot<replaceable>#</replaceable>/tftp</userinput>, onde
<replaceable>#</replaceable> é o número do dispositivo TurboChannel
que será inicializado. Na maioria das DECstations este número é
o "3". Se o servidor BOOTP/DHCP não fornecer o nome de arquivo
ou você precisar passar parâmetros adicionais, você eles poderão 
ser opcionalmente adicionados com a seguinte sintaxe:

</para><para>

<userinput>boot #/tftp/filename param1=value1 param2=value2 ...</userinput>

</para><para>

Diversas revisões da firmware da DECstation mostram um problema
se tratanto com a inicialização via rede: a transferência 
inicia, mas após algum tempo ela para com o erro 
<computeroutput>a.out err</computeroutput>. Isto pode ter diversas 
razões:

<orderedlist>
<listitem><para>

A firmware não responde a uma requisição ARP durante uma 
transferência TFTP. Isto leva a um timeout de ARP e a transferência é
interrompida. A solução é adicionar o endereço MAC da 
placa ethernet na DECstation estaticamente para a tabela ARP do 
servidor de TFTP. Isto é feito rodando <userinput>arp -s
<replaceable>IP-address</replaceable>
<replaceable>MAC-address</replaceable></userinput> como root na 
máquina que atua como servidor TFTP. O endereço MAC da DECstation
pode ser lido entrando com o comando <command>cnfg</command> 
no aviso da firmware da DECstation.

</para></listitem>
<listitem><para>

A firmware tem o limite de tamanho nos arquivos que podem ser 
inicializados através do TFTP.

</para></listitem>
</orderedlist>

Existem também revisões de firmware que não podem ser inicializadas 
através do TFTP. Uma visão sobre as diferentes revisões de firmware
podem ser encontradas nas páginas web do NetBSD:
<ulink url="http://www.netbsd.org/Ports/pmax/board-list.html#proms"></ulink>.

</para>
   </sect3>

   <sect3 arch="alpha">
   <title>Inicialização via TFTP no Alpha</title>
<para>
No Alpha, você deverá especificar um nome de arquivo (como um 
caminho relativo ao diretório da imagem de inicialização) 
usando o argumento <userinput>-file</userinput> ou o comando 
<userinput>boot</userinput> do SRM ou definindo a variável de 
ambiente <userinput>BOOT_FILE</userinput>. Alternativamente, o nome 
do arquivo deverá ser fornecido via BOOTP (no <command>dhcpd</command> da ISC,
use a diretiva <userinput>filename</userinput>). Ao contrário da 
Open Firmware,  <emphasis>não existe nome padrão</emphasis> no SRM, assim
você <emphasis>deverá</emphasis> especificar um nome de arquivo
usando um destes métodos.

</para>
   </sect3>

   <sect3 arch="sparc">
   <title>Inicialização via TFTP no SPARC</title>
<para>

As arquiteturas SPARC usam os nomes de sub-arquiteturas, tais como
"SUN4M" ou "SUN4C"; em alguns casos, a arquitetura é deixada em 
branco, assim o arquivo que o cliente procura é simplesmente
<filename>client-ip-in-hex</filename>. Assim, caso a sub-arquitetura 
do seu sistema seja SUN4C e seu endereço IP 192.168.1.3, o nome 
de arquivo deverá ser <filename>C0A80103.SUN4C</filename>.

</para><para>

Você também poderá forçar alguns sistemas sparc a procurar por 
nomes de arquivos específicos adicionando-o no final da linha de 
comando, por exemplo
<userinput>boot net my-sparc.image</userinput>. Este arquivo também
deverá residir no diretório que o servidor TFTP procura.

</para>
   </sect3>

   <sect3 arch="m68k">
   <title>Inicialização TFTP no BVM/Motorola</title>
<para>

Para os sistemas BVM e Motorola VMEbus copie os arquivos
&bvme6000-tftp-files; para <filename>/tftpboot/</filename>.

</para><para>

A seguir, configure o servidor BOOTP ou boot ROMs para 
carregar inicialmente o arquivo <filename>tftplilo.bvme</filename> ou
<filename>tftplilo.mvme</filename> a partir do servidor TFTP. Veja o 
arquivo <filename>tftplilo.txt</filename> de sua sub-arquitetura para 
informações adicionais específicas de sistema.

</para>
   </sect3>

   <sect3 arch="mips">
   <title>Inicialização TFTP nos Indys SGI</title>
<para>

Nos Indys SGI você poderá usar o <command>bootpd</command> para 
fornecer o nome do arquivo TFTP. Ele poderá ser fornecido na 
forma <userinput>bf=</userinput> no <filename>/etc/bootptab</filename> ou
como opção <userinput>filename=</userinput> no arquivo
<filename>/etc/dhcpd.conf</filename>.

</para>
   </sect3>
  </sect2>

  <sect2 id="tftp-low-memory">
  <title>Instalação via TFTP em sistemas com pouca memória</title>
<para>

Em alguns sistemas, o disco RAM de instalação padrão, combinado
com os requerimentos de memória da imagem de inicialização do TFTP,
não cabem na memória. Neste caso, você ainda poderá instalar usando 
o TFTP, você terá que ir através do passo adicional de montagem
do sistema de arquivos raíz via NFS pela rede também. Este tipo de 
configuração também é apropriada para clientes sem discos (diskless) ou 
sem dados (dataless).

</para><para>

Primeiro, siga todos os passos acima descritos em <xref linkend="install-tftp"/>.

<orderedlist>
<listitem><para>

Copie a imagem do kernel do Linux para seu servidor TFTP
usando a imagem <userinput>a.out</userinput> para a arquitetura
que estiver inicializando.

</para></listitem>
<listitem><para>

Descompacte o arquivo raíz tar em seu servidor NFS (pode ser o mesmo
sistema que seu servidor TFTP): 

<informalexample><screen>

# cd /tftpboot
# tar xvzf root.tar.gz

</screen></informalexample>

Tenha certeza de utilizar o comando <command>tar</command> da GNU (ao invés
de outros programas, como o do SunOS, que manipula os dispositivos de 
forma incorreta como texto plano).

</para></listitem>
<listitem><para>

Exporte seu diretório <filename>/tftpboot/debian-sparc-root</filename>
com acesso root para seus clientes. E.g., adicione a seguinte linha
ao seu arquivo <filename>/etc/exports</filename> (sintaxe do GNU/Linux, 
deverá ser similar no SunOS):

<informalexample><screen>

/tftpboot/debian-sparc-root cliente(rw,no_root_squash)

</screen></informalexample>

NOTA: "cliente" é o nome de estação ou endereço IP reconhecido pelo
servidor para o sistema que deseja inicializar.

</para></listitem>
<listitem><para>

Crie um link simbólico do endereço IP do seu cliente em notação
pontuada para o arquivo <filename>debian-sparc-root</filename> no 
diretório <filename>/tftpboot</filename> directory. Por exemplo, 
caso o endereço IP do cliente seja 192.168.1.3, faça

<informalexample><screen>

# ln -s debian-sparc-root 192.168.1.3

</screen></informalexample>

</para></listitem>
</orderedlist>

</para>

  </sect2>

  <sect2 condition="supports-nfsroot">
  <title>Instalando com o TFTP e NFS root</title>
<para>

A instalação com TFTP e NFS raíz é similar a
<xref linkend="tftp-low-memory"/> porque você não precisará 
carregar o disco RAM mais mas inicializará através do seu novo
sistema de arquivos NFS criado. Você precisará então substituir o link 
simbólico para a imagem tftpboot por um link simbólico apontando para
uma imagem de kernel (por exemplo,
<filename>linux-a.out</filename>).

</para><para>

O RARP/TFTP requer que todos os daemons estejam sendo executados no 
mesmo servidor (a estação de trabalho que estiver enviando requisições
TFTP de volta para o servidor que respondeu a requisição RARP anterior).

</para>

  </sect2>
 </sect1>
