<!-- Start of file partitioning/partitioning.xml -->
<!-- $Id: partitioning.xml 11648 2004-03-22 00:37:46Z joeyh $ -->

<appendix id="partitioning">
<title>Partitioning for Debian</title>


<!-- Start of file partitioning/sizing.xml -->
<!-- $Id: sizing.xml 11648 2004-03-22 00:37:46Z joeyh $ -->


 <sect1 id="partition-sizing">
 <title>Deciding on Debian Partitions and Sizes</title>
<para>

At a bare minimum, GNU/Linux needs one partition for itself.  You can
have a single partition containing the entire operating system,
applications, and your personal files. Most people feel that a
separate swap partition is also a necessity, although it's not
strictly true.  <quote>Swap</quote> is scratch space for an operating system,
which allows the system to use disk storage as <quote>virtual
memory</quote>. By putting swap on a separate partition, Linux can make much
more efficient use of it.  It is possible to force Linux to use a
regular file as swap, but it is not recommended.

</para><para>

Most people choose to give GNU/Linux more than the minimum number of
partitions, however.  There are two reasons you might want to break up
the file system into a number of smaller partitions. The first is for
safety.  If something happens to corrupt the file system, generally
only one partition is affected. Thus, you only have to replace (from
the backups you've been carefully keeping) a portion of your
system. At a bare minimum, you should consider creating what is
commonly called a <quote>root partition</quote>. This contains the most essential
components of the system. If any other partitions get corrupted, you
can still boot into GNU/Linux to fix the system. This can save you the
trouble of having to reinstall the system from scratch.

</para><para>

The second reason is generally more important in a business setting,
but it really depends on your use of the machine. For example, a mail
server getting spammed with e-mail can easily fill a partition. If you
made <filename>/var/mail</filename> a separate partition on the mail
server, most of the system will remain working even if you get spammed.

</para><para>

The only real drawback to using more partitions is that it is often
difficult to know in advance what your needs will be. If you make a
partition too small then you will either have to reinstall the system
or you will be constantly moving things around to make room in the
undersized partition. On the other hand, if you make the partition too
big, you will be wasting space that could be used elsewhere. Disk
space is cheap nowadays, but why throw your money away?

</para>
 </sect1>
<!--   End of file partitioning/sizing.xml -->

<!-- Start of file partitioning/tree.xml -->
<!-- $Id: tree.xml 25496 2005-02-07 14:56:06Z fjpop-guest $ -->


 <sect1 id="directory-tree">
 <title>The Directory Tree</title>
<para>

&debian; adheres to the 
<ulink url="&url-fhs-home;">Filesystem Hierarchy Standard</ulink>
for directory and file naming. This standard allows users and software
programs to predict the location of files and directories. The root
level directory is represented simply by the slash
<filename>/</filename>. At the root level, all Debian systems include
these directories:

<informaltable>
<tgroup cols="2">
<thead>
<row>
  <entry>Directory</entry><entry>Content</entry>
</row>
</thead>

<tbody>
<row>
  <entry><filename>bin</filename></entry>
  <entry>Essential command binaries</entry>
</row><row>
  <entry><filename>boot</filename></entry>
  <entry>Static files of the boot loader</entry>
</row><row>
  <entry><filename>dev</filename></entry>
  <entry>Device files</entry>
</row><row>
  <entry><filename>etc</filename></entry>
  <entry>Host-specific system configuration</entry>
</row><row>
  <entry><filename>home</filename></entry>
  <entry>User home directories</entry>
</row><row>
  <entry><filename>lib</filename></entry>
  <entry>Essential shared libraries and kernel modules</entry>
</row><row>
  <entry><filename>mnt</filename></entry>
  <entry>Mount point for mounting a file system temporarily</entry>
</row><row>
  <entry><filename>proc</filename></entry>
  <entry>Virtual directory for system information</entry>
</row><row>
  <entry><filename>root</filename></entry>
  <entry>Home directory for the root user</entry>
</row><row>
  <entry><filename>sbin</filename></entry>
  <entry>Essential system binaries</entry>
</row><row>
  <entry><filename>tmp</filename></entry>
  <entry>Temporary files</entry>
</row><row>
  <entry><filename>usr</filename></entry>
  <entry>Secondary hierarchy</entry>
</row><row>
  <entry><filename>var</filename></entry>
  <entry>Variable data</entry>
</row><row>
  <entry><filename>opt</filename></entry>
  <entry>Add-on application software packages</entry>
</row>
</tbody></tgroup></informaltable>
</para>

<para>

The following is a list of important considerations regarding
directories and partitions.

</para>
<itemizedlist>
<listitem><para>

The root partition <filename>/</filename> must always physically
contain <filename>/etc</filename>, <filename>/bin</filename>,
<filename>/sbin</filename>, <filename>/lib</filename> and
<filename>/dev</filename>, otherwise you won't be able to boot.
Typically 100 MB is needed for the root partition, but this may vary.

</para></listitem>
<listitem><para>

<filename>/usr</filename>: all user programs
(<filename>/usr/bin</filename>), libraries
(<filename>/usr/lib</filename>), documentation
(<filename>/usr/share/doc</filename>), etc., are in this
directory. This part of the file system needs most of the space. You
should provide at least 500 MB of disk space. If you want to install
more packages you should increase the amount of space you give this
directory.

</para></listitem>
<listitem><para>

<filename>/home</filename>: every user will put his data into a
subdirectory of this directory. The size of this depends on how many
users will be using the system and what files are to be stored in
their directories.  Depending on your planned usage you should reserve
about 100 MB for each user, but adapt this value to your needs.

</para></listitem>
<listitem><para>

<filename>/var</filename>: all variable data like news articles,
e-mails, web sites, the packaging system cache, etc. will be placed
under this directory. The size of this directory depends greatly on
the usage of your computer, but for most people will be dictated by
the package management tool's overhead.  If you are going to do a full
installation of just about everything Debian has to offer, all in one
session, setting aside 2 or 3 gigabytes of space for
<filename>/var</filename> should be sufficient. If you are going to
install in pieces (that is to say, install services and utilities,
followed by text stuff, then X, ...), you can get away with 300&ndash;500
megabytes in <filename>/var</filename>.  If hard drive space is at a
premium and you don't plan on doing major system updates, you can get
by with as little as 30 or 40 megabytes in <filename>/var</filename>.

</para></listitem>
<listitem><para>

<filename>/tmp</filename>: if a program creates temporary data it will
most likely go in <filename>/tmp</filename>. 20-50 MB should usually
be enough.

</para></listitem>
</itemizedlist>

 </sect1>
<!--   End of file partitioning/tree.xml -->

<!-- Start of file partitioning/schemes.xml -->
<!-- $Id: schemes.xml 18917 2004-08-08 20:38:32Z joeyh $ -->


 <sect1>
 <title>Recommended Partitioning Scheme</title>
<para>

For new users, personal Debian boxes, home systems, and other
single-user setups, a single <filename>/</filename> partition (plus
swap) is probably the easiest, simplest way to go.  However, if your
partition is larger than around 6GB, choose ext3 as your partition
type.  Ext2 partitions need periodic file system integrity checking,
and this can cause delays during booting when the partition is large.

</para><para>

For multi-user systems or systems with lots of disk space, it's best
to put <filename>/usr</filename>, <filename>/var</filename>,
<filename>/tmp</filename>, and <filename>/home</filename> each on
their own partitions separate from the <filename>/</filename>
partition.

</para><para>

You might need a separate <filename>/usr/local</filename> partition if
you plan to install many programs that are not part of the Debian
distribution.  If your machine will be a mail server, you might need
to make <filename>/var/mail</filename> a separate partition.  Often,
putting <filename>/tmp</filename> on its own partition, for instance
20 to 50MB, is a good idea.  If you are setting up a server with lots
of user accounts, it's generally good to have a separate, large
<filename>/home</filename> partition.  In general, the partitioning
situation varies from computer to computer depending on its uses.

</para><para>

For very complex systems, you should see the 
<ulink url="&url-multidisk-howto;">
Multi Disk HOWTO</ulink>.  This contains in-depth information, mostly
of interest to ISPs and people setting up servers.

</para><para>

With respect to the issue of swap partition size, there are many
views.  One rule of thumb which works well is to use as much swap as
you have system memory. It also shouldn't be smaller than 16MB, in
most cases.  Of course, there are exceptions to these rules. If you
are trying to solve 10000 simultaneous equations on a machine with
256MB of memory, you may need a gigabyte (or more) of swap.  

</para><para arch="m68k"> 

On the other hand, Atari Falcons and Macs feel pain when swapping, so
instead of making a large swap partition, get as much RAM as possible.

</para><para>

On 32-bit architectures (i386, m68k, 32-bit SPARC, and PowerPC), the
maximum size of a swap partition is 2GB. That should be enough for
nearly any installation.  However, if your swap requirements are this
high, you should probably try to spread the swap across different
disks (also called <quote>spindles</quote>) and, if possible, different SCSI or
IDE channels.  The kernel will balance swap usage between multiple
swap partitions, giving better performance.

</para><para>

As an example, an older home machine might have 32MB of RAM and a
1.7GB IDE drive on <filename>/dev/hda</filename>. There might be a
500MB partition for another operating system on
<filename>/dev/hda1</filename>, a 32MB swap partition on
<filename>/dev/hda3</filename> and about 1.2GB on
<filename>/dev/hda2</filename>) as the Linux partition.

</para><para>

For an idea of the space taken by tasks
you might be interested in adding after your system installation is 
complete, check <xref linkend="tasksel-size-list"/>.

</para>

 </sect1>
<!--   End of file partitioning/schemes.xml -->

<!-- Start of file partitioning/device-names.xml -->
<!-- $Id: device-names.xml 18767 2004-07-31 14:14:52Z mck-guest $ -->


 <sect1 id="device-names">
 <title>Device Names in Linux</title>
<para>

Linux disks and partition names may be different from other operating
systems.  You need to know the names that Linux uses when you create
and mount partitions. Here's the basic naming scheme:

</para>
<itemizedlist arch="not-s390">
<listitem><para>

The first floppy drive is named <filename>/dev/fd0</filename>.

</para></listitem>
<listitem><para>

The second floppy drive is named <filename>/dev/fd1</filename>.

</para></listitem>
<listitem><para>

The first SCSI disk (SCSI ID address-wise) is named
<filename>/dev/sda</filename>.

</para></listitem>
<listitem><para>

The second SCSI disk (address-wise) is named
<filename>/dev/sdb</filename>, and so on.

</para></listitem>
<listitem><para>

The first SCSI CD-ROM is named <filename>/dev/scd0</filename>, also
known as <filename>/dev/sr0</filename>.

</para></listitem>
<listitem><para>

The master disk on IDE primary controller is named
<filename>/dev/hda</filename>.

</para></listitem>
<listitem><para>

The slave disk on IDE primary controller is named
<filename>/dev/hdb</filename>.

</para></listitem>
<listitem><para>

The master and slave disks of the secondary controller can be called
<filename>/dev/hdc</filename> and <filename>/dev/hdd</filename>,
respectively.  Newer IDE controllers can actually have two channels,
effectively acting like two controllers.

<phrase arch="m68k">
The letters may differ from what shows in the mac program pdisk
(i.e. what shows up as <filename>/dev/hdc</filename> on pdisk may show
up as <filename>/dev/hda</filename> in Debian). 
</phrase>

</para></listitem>

<listitem arch="i386"><para>

The first XT disk is named <filename>/dev/xda</filename>.

</para></listitem>
<listitem arch="i386"><para>

The second XT disk is named <filename>/dev/xdb</filename>.

</para></listitem>
<listitem arch="m68k"><para>

The first ACSI device is named <filename>/dev/ada</filename>, the
second is named <filename>/dev/adb</filename>.  

</para></listitem>
</itemizedlist>

<itemizedlist arch="s390">
<listitem><para>

The first DASD device is named
<filename>/dev/dasda</filename>.

</para></listitem>
<listitem><para>

The second DASD device is named
<filename>/dev/dasdb</filename>, and so on.

</para></listitem>
</itemizedlist>

<para arch="not-s390">

The partitions on each disk are represented by appending a decimal
number to the disk name: <filename>sda1</filename> and
<filename>sda2</filename> represent the first and
second partitions of the first SCSI disk drive in your system.

</para><para arch="not-s390">

Here is a real-life example.  Let's assume you have a system with 2
SCSI disks, one at SCSI address 2 and the other at SCSI address 4.
The first disk (at address 2) is then named <filename>sda</filename>,
and the second <filename>sdb</filename>.  If the
<filename>sda</filename> drive has 3 partitions on it, these will be
named <filename>sda1</filename>, <filename>sda2</filename>, and
<filename>sda3</filename>.  The same applies to the
<filename>sdb</filename> disk and its partitions.

</para><para arch="not-s390">

Note that if you have two SCSI host bus adapters (i.e., controllers),
the order of the drives can get confusing.  The best solution in this
case is to watch the boot messages, assuming you know the drive models
and/or capacities.

</para><para arch="i386">

Linux represents the primary partitions as the drive name, plus the
numbers 1 through 4.  For example, the first primary partition on the
first IDE drive is <filename>/dev/hda1</filename>.  The logical partitions are
numbered starting at 5, so the first logical partition on that same
drive is <filename>/dev/hda5</filename>.  Remember that the extended
partition, that is, the primary partition holding the logical
partitions, is not usable by itself.  This applies to SCSI disks as
well as IDE disks.

</para><para arch="m68k">

VMEbus systems using the TEAC FC-1 SCSI floppy drive will see it as normal
SCSI disk. To make identification of the drive simpler the installation
software will create a symbolic link to the appropriate device and name
it <filename>/dev/sfd0</filename>.

</para><para arch="sparc">

Sun disk partitions allow for 8 separate partitions (or slices). The
third partition is usually (and is preferred to have) the ``Whole Disk''
partition. This partition references all of the sectors of the disk, and
is used by the boot loader (either SILO, or Sun's).

</para><para arch="s390">

The partitions on each disk are represented by appending a decimal
number to the disk name: <filename>dasda1</filename> and
<filename>dasda2</filename> represent the first and
second partitions of the first DASD device in your system.

</para>
 </sect1>
<!--   End of file partitioning/device-names.xml -->

<!-- Start of file partitioning/partition-programs.xml -->
<!-- $Id: partition-programs.xml 24663 2004-12-31 18:38:22Z fjpop-guest $ -->

 <sect1 id="partition-programs">
 <title>Debian Partitioning Programs</title>
<para>

Several varieties of partitioning programs have been adapted by Debian
developers to work on various types of hard disks and computer
architectures. Following is a list of the program(s) applicable for
your architecture.

</para>

<variablelist>

<varlistentry>
<term><command>partman</command></term>
<listitem><para>

Recommended partitioning tool in Debian. This swiss army knife can
also resize partitions, create filesystems
<phrase arch="i386"> (<quote>format</quote> in Windows speak)</phrase>
and assign them to the mountpoints.

</para></listitem>
</varlistentry>

<varlistentry condition="fdisk.txt">
<term><command>fdisk</command></term>
<listitem><para>

 The original Linux disk partitioner, good for gurus; read the 
<ulink url="fdisk.txt">fdisk manual page</ulink> .

</para><para>

Be careful if you have existing FreeBSD partitions on your machine.
The installation kernels include support for these partitions, but the
way that <command>fdisk</command> represents them (or not) can make the
device names differ.  See the 
<ulink url="&url-linux-freebsd;">Linux+FreeBSD HOWTO</ulink>

</para></listitem>
</varlistentry>

<varlistentry condition="cfdisk.txt">
<term><command>cfdisk</command></term>
<listitem><para>

A simple-to-use, full-screen disk partitioner for the rest of us; read
the <ulink url="cfdisk.txt">cfdisk manual page</ulink>.

</para><para>

Note that <command>cfdisk</command> doesn't understand FreeBSD
partitions at all, and, again, device names may differ as a result.

</para></listitem>
</varlistentry>

<varlistentry condition="atari-fdisk.txt">
<term><command>atari-fdisk</command></term>
<listitem><para>

Atari-aware version of <command>fdisk</command>; read the 
<ulink url="atari-fdisk.txt">atari-fdisk manual page</ulink>.

</para></listitem>
</varlistentry>

<varlistentry condition="amiga-fdisk.txt">
<term><command>amiga-fdisk</command></term>
<listitem><para>

Amiga-aware version of <command>fdisk</command>; read the 
<ulink url="amiga-fdisk.txt">amiga-fdisk manual page</ulink>.

</para></listitem>
</varlistentry>

<varlistentry condition="mac-fdisk.txt">
<term><command>mac-fdisk</command></term>
<listitem><para>

Mac-aware version of <command>fdisk</command>; read the 
<ulink url="mac-fdisk.txt">mac-fdisk manual page</ulink>.

</para></listitem>
</varlistentry>

<varlistentry condition="pmac-fdisk.txt">
<term><command>pmac-fdisk</command></term>
<listitem><para>

PowerMac-aware version of <command>fdisk</command>, also used by BVM
and Motorola VMEbus systems; read the 
<ulink url="pmac-fdisk.txt">pmac-fdisk manual page</ulink>.

</para></listitem>
</varlistentry>

<varlistentry condition="fdasd.txt">
<term><command>fdasd</command></term>
<listitem><para>

&arch-title; version of <command>fdisk</command>; Please read the
<ulink url="fdasd.txt">fdasd manual page</ulink> or chapter 13 in
<ulink url="http://oss.software.ibm.com/developerworks/opensource/linux390/docu/l390dd08.pdf">
Device Drivers and Installation Commands</ulink> for details. 

</para></listitem>
</varlistentry>
</variablelist>

<para>

One of these programs will be run by default when you select
<guimenuitem>Partition a Hard Disk</guimenuitem>.  If the one which is run by default isn't
the one you want, quit the partitioner, go to the shell
(<userinput>tty2</userinput>) by pressing <keycap>Alt</keycap>
and <keycap>F2</keycap> keys together, and manually type in the
name of the program you want to use (and arguments, if any).  Then
skip the <guimenuitem>Partition a Hard Disk</guimenuitem> step in
<command>debian-installer</command> and continue to the next step.

</para><para>

If you will be working with more than 20 partitions on your ide disk,
you will need to create devices for partitions 21 and beyond. The next
step of initializing the partition will fail unless a proper device is
present. As an example, here are commands you can use in
<userinput>tty2</userinput> or under Execute A Shell to add a device
so the 21st partition can be initialized:

<informalexample><screen>
# cd /dev
# mknod hda21 b 3 21 
# chgrp disk hda21
# chmod 660 hda21
</screen></informalexample>

Booting into the new system will fail unless proper devices are present
on the target system. After installing the kernel and modules, execute:

<informalexample><screen>
# cd /target/dev
# mknod hda21 b 3 21 
# chgrp disk hda21
# chmod 660 hda21
</screen></informalexample>

<phrase arch="i386">Remember to mark your boot partition as
<quote>Bootable</quote>.</phrase>

</para><para condition="mac-fdisk.txt">

See the 
<ulink url="mac-fdisk.txt">mac-fdisk manual page</ulink> for
information on how to create partitions.  One key point, is that the
swap partition is identified on Mac type disks by its name; it must be
named `swap'. All Mac linux partitions are the same partition type, 
Apple_UNIX_SRV2. Please read the fine manual. We also suggest reading the 
<ulink url="&url-mac-fdisk-tutorial;">mac-fdisk Tutorial</ulink>, which
includes steps you should take if you are sharing your disk with
MacOS.  

</para>


<!-- Start of file partitioning/partition/alpha.xml -->
<!-- $Id: alpha.xml 25496 2005-02-07 14:56:06Z fjpop-guest $ -->


  <sect2 arch="alpha"><title>Partitioning for &arch-title;</title>
<para>

Booting Debian from the SRM console (the only disk boot method supported
by &releasename;) requires you to have a BSD disk label, not a DOS
partition table, on your boot disk.  (Remember, the SRM boot block is
incompatible with MS-DOS partition tables &mdash; see
<xref linkend="alpha-firmware"/>.)  As a result, <command>partman</command>
creates BSD disk labels when running on &architecture;, but if your disk
has an existing DOS partition table the existing partitions will need to
be deleted before partman can convert it to use a disk label.

</para><para>

If you have chosen to use <command>fdisk</command> to partition your
disk, and the disk that you have selected for partitioning does not
already contain a BSD disk label, you must use the `b' command to enter
disk label mode.

</para><para>

Unless you wish to use the disk you are partitioning from Tru64 Unix
or one of the free 4.4BSD-Lite derived operating systems (FreeBSD,
OpenBSD, or NetBSD), it is suggested that you do
<emphasis>not</emphasis> make the third partition contain the whole
disk.  This is not required by <command>aboot</command>, and in fact,
it may lead to confusion since the <command>swriteboot</command>
utility used to install <command>aboot</command> in the boot sector
will complain about a partition overlapping with the boot block.

</para><para>

Also, because <command>aboot</command> is written to the first few
sectors of the disk (currently it occupies about 70 kilobytes, or 150
sectors), you <emphasis>must</emphasis> leave enough empty space at
the beginning of the disk for it.  In the past, it was suggested that
you make a small partition at the beginning of the disk, to be left
unformatted.  For the same reason mentioned above, we now suggest that
you do not do this on disks that will only be used by GNU/Linux.  When
using <command>partman</command>, a small partition will still be
created for <command>aboot</command> for convenience reasons.

</para><para condition="FIXME">

For ARC installations, you should make a small FAT partition at the
beginning of the disk to contain <command>MILO</command> and
<command>linload.exe</command> &mdash; 5 megabytes should be sufficient, see
<xref linkend="non-debian-partitioning"/>. Unfortunately, making FAT
file systems from the menu is not yet supported, so you'll have to do
it manually from the shell using <command>mkdosfs</command> before
attempting to install the boot loader.

</para>
  </sect2>
<!--   End of file partitioning/partition/alpha.xml -->

<!-- Start of file partitioning/partition/hppa.xml -->
<!-- $Id: hppa.xml 11648 2004-03-22 00:37:46Z joeyh $ -->


  <sect2 arch="hppa"><title>Partitioning for &arch-title;</title>
<para>

PALO, the HPPA boot loader, requires a partition of type <quote>F0</quote> somewhere
in the first 2GB.  This is where the boot loader and an optional kernel
and RAMdisk will be stored, so make it big enough for that -- at least
4Mb (I like 8-16Mb).  An additional requirement of the firmware is that
the Linux kernel must reside within the first 2GB of the disk.  This
is typically achieved by making the root ext2 partition fit entirely
within the first 2GB of the disk.  Alternatively you can create a small
ext2 partition near the start of the disk and mount that on
<filename>/boot</filename>, since that is the directory where the Linux
kernel(s) will be stored.  <filename>/boot</filename> needs to be big enough
to hold whatever kernels you might wish load; 8-16MB is generally
sufficient.

</para>
  </sect2>
<!--   End of file partitioning/partition/hppa.xml -->

<!-- Start of file partitioning/partition/i386.xml -->
<!-- $Id: i386.xml 24574 2004-12-27 00:09:09Z fjpop-guest $ -->


  <sect2 arch="i386"><title>Partitioning for &arch-title;</title>
<para>

If you have an existing other operating system such as DOS or Windows and
you want to preseve that operating system while installing Debian, you may
need to resize its partition to free up space for the Debian installation.
The installer supports resizing of both FAT and NTFS filesystems; when you
get to the installer's partitioning step, select the option to partition
manually and then simply select an existing partition and change its size. 

</para><para>

The PC BIOS generally adds additional constraints for disk
partitioning.  There is a limit to how many <quote>primary</quote> and
<quote>logical</quote> partitions a drive can contain.  Additionally, with pre
1994-98 BIOS, there are limits to where on the drive the BIOS can boot
from.  More information can be found in the
<ulink url="&url-partition-howto;">Linux Partition HOWTO</ulink> and the
<ulink url="&url-phoenix-bios-faq-large-disk;">Phoenix BIOS FAQ</ulink>, but
this section will include a brief overview to help you plan most
situations.

</para><para>

<quote>Primary</quote> partitions are the original partitioning scheme for PC
disks.  However, there can only be four of them.  To get past this
limitation, <quote>extended</quote> and <quote>logical</quote> partitions were invented.  By
setting one of your primary partitions as an extended partition, you
can subdivide all the space allocated to that partition into logical
partitions.  You can create up to 60 logical partitions per extended
partition; however, you can only have one extended partition per
drive.

</para><para>

Linux limits the partitions per drive to 15 partitions for SCSI disks
(3 usable primary partitions, 12 logical partitions), and 63
partitions on an IDE drive (3 usable primary partitions, 60 logical
partitions). However the normal &debian; system provides 
only 20 devices for partitions, so you may not install on partitions
higher than 20 unless you first manually create devices for those
partitions. 

</para><para>

If you have a large IDE disk, and are using neither LBA addressing,
nor overlay drivers (sometimes provided by hard disk manufacturers),
then the boot partition (the partition containing your kernel image)
must be placed within the first 1024 cylinders of your hard drive
(usually around 524 megabytes, without BIOS translation).

</para><para>

This restriction doesn't apply if you have a BIOS newer than around
1995-98 (depending on the manufacturer) that supports the <quote>Enhanced
Disk Drive Support Specification</quote>.  Both Lilo, the Linux loader, and
Debian's alternative <command>mbr</command> must use the BIOS to read the
kernel from the disk into RAM.  If the BIOS int 0x13 large disk access
extensions are found to be present, they will be utilized. Otherwise,
the legacy disk access interface is used as a fall-back, and it cannot
be used to address any location on the disk higher than the 1023rd
cylinder.  Once Linux is booted, no matter what BIOS your computer
has, these restrictions no longer apply, since Linux does not use the
BIOS for disk access.

</para><para>

If you have a large disk, you might have to use cylinder translation
techniques, which you can set from your BIOS setup program, such as
LBA (Logical Block Addressing) or CHS translation mode (<quote>Large</quote>).
More information about issues with large disks can be found in the
<ulink url="&url-large-disk-howto;">Large Disk HOWTO</ulink>.  If you
are using a cylinder translation scheme, and the BIOS does not support
the large disk access extensions, then your boot partition has to fit
within the <emphasis>translated</emphasis> representation of the
1024th cylinder.

</para><para>

The recommended way of accomplishing this is to create a small (5-10MB
should suffice) partition at the beginning of the disk to be used as
the boot partition, and then create whatever other partitions you wish
to have, in the remaining area.  This boot partition
<emphasis>must</emphasis> be mounted on <filename>/boot</filename>,
since that is the directory where the Linux kernel(s) will be stored.
This configuration will work on any system, regardless of whether LBA
or large disk CHS translation is used, and regardless of whether your
BIOS supports the large disk access extensions.

</para>
  </sect2>
<!--   End of file partitioning/partition/i386.xml -->

<!-- Start of file partitioning/partition/ia64.xml -->
<!-- $Id: ia64.xml 24663 2004-12-31 18:38:22Z fjpop-guest $ -->


  <sect2 arch="ia64"><title>Partitioning for &arch-title;</title>

<para>

The <command>partman</command> disk partitioner is the default
partitioning tool for the installer.
It manages the set of partitions and their mount points to ensure
that the disks and filesystems is properly configured for a successful 
installation.  It actually uses the <command>parted</command> to
do the on-disk partitioning.

</para>

   <note>
   <title>EFI Recognized Formats</title>
<para>

The IA64 EFI firmware supports two partition table (or disk label)
formats, GPT and MS-DOS.  MS-DOS, the format typically used on i386
PCs, is no longer recommended for IA64 systems.  Although
the installer also provides the <command>cfdisk</command>,
you should only use the <ulink url="parted.txt">
<command>parted</command></ulink> because only it can manage both GPT
and MS-DOS tables correctly.

</para></note>

<para>

The automatic partitioning recipes for <command>partman</command>
allocate an EFI partition as the first partition on the disk.
You can also set up the partition under the <guimenuitem>Guided
partitioning</guimenuitem> from the main menu in a manner similar to
setting up a <emphasis>swap</emphasis> partition.

</para><para>

The <command>partman</command> partitioner will handle most disk
layouts.
For those rare cases where it is necessary to manually set up a disk,
you can use the shell as described above and run the
<command>parted</command> utility directly using its command line interface.
Assuming that you want to erase your whole disk and create a GPT table
and some partitions, then something similar to the following command
sequence could be used:

<informalexample><screen>
      mklabel gpt
      mkpartfs primary fat 0 50
      mkpartfs primary linux-swap 51 1000
      mkpartfs primary ext2 1001 3000
      set 1 boot on
      print
      quit
</screen></informalexample>

This creates a new partition table, and three partitions to be used as
an EFI boot partition, swap space, and a root file system.  Finally it
sets the boot flag on the EFI partition.  Partitions are specified in
Megabytes, with start and end offsets from the beginning of the disk.
So, for example, above we created a 1999MB ext2 file system starting
at offset 1001MB from the start of the disk.  Note that formatting swap
space with <command>parted</command> can take a few minutes to
complete, as it scans the partition for bad blocks.

</para>
  </sect2>

  <sect2 arch="ia64"><title>Boot Loader Partition Requirements</title>

<para>

ELILO, the ia64 boot loader, requires a partition containing a FAT
file system with the <userinput>boot</userinput> flag set.
The partition must be big enough to hold the boot loader and any
kernels or RAMdisks you may wish to boot.  A minimum size would be
about 20MB, but if you expect to run with multiple kernels, then
128MB might be a better size.

</para><para>

The EFI Boot Manager and the EFI Shell fully support the GPT table
so the boot partition does not necessarily have to be the first
partition or even on the same disk.
This is convenient if you should forget to allocate the partition and
only find out after you have formatted the other partitions on your disk(s).
The <command>partman</command> partitioner checks for an EFI partition
at the same time it checks for a properly set up <emphasis>root</emphasis>
partition.
This gives you an opportunity to correct the disk layout before the
package install begins.
The easiest way to correct this omission is to shrink the last partition
of the disk to make enough free space for adding an EFI partition.

</para><para>

It is strongly recommended that you allocate the EFI boot partition
on the same disk as the <emphasis>root</emphasis> filesystem.

</para>

  </sect2>

  <sect2 arch="ia64"><title>EFI Diagnostic Partitions</title>

<para>

The EFI firmware is significantly more sophisticated than the usual
BIOS seen on most x86 PCs.
Some system vendors take advantage of the ability of the EFI to
access files and run programs from a hard disk filesystem to store diagnostics
and EFI based system management utilities on the hard disk.
This is a separate FAT format filesystem on the system disk.
Consult the system documentation and accessories that come with the
system for details.
The easiest time to set up a diagnostics partition is at the same time you
set up the EFI boot partition.

</para>

   </sect2>
<!--   End of file partitioning/partition/ia64.xml -->

<!-- Start of file partitioning/partition/mips.xml -->
<!-- $Id: mips.xml 22939 2004-10-09 23:27:48Z ths-guest $ -->


  <sect2 arch="mips"><title>Partitioning for &arch-title;</title>
<para>

SGI Indys require an SGI disk label in order to make the system bootable 
from hard disk. It can be created in the fdisk expert menu. The thereby
created volume header(partition number 9) should be at least 3MB large.
If the volume header created is too small, you can simply delete
partition number 9 and re-add it with a different size. Note that the
volume header must start at sector 0.

</para>
  </sect2>
<!--   End of file partitioning/partition/mips.xml -->

<!-- Start of file partitioning/partition/powerpc.xml -->
<!-- $Id: powerpc.xml 23146 2004-10-16 14:20:10Z cjwatson $ -->


  <sect2 arch="powerpc"><title>Partitioning Newer PowerMacs</title>
<para>

If you are installing onto a NewWorld PowerMac you must create a
special bootstrap partition to hold the boot loader. The size of this
partition must be 800KB and its partition type must be
<emphasis>Apple_Bootstrap</emphasis>.  If the bootstrap partition is
not created with the <emphasis>Apple_Bootstrap</emphasis> type your
machine cannot be made bootable from the hard disk.  This partition
can easily be created by creating a new partition in
<command>partman</command> and telling it to use it as a <quote>NewWorld
boot partition</quote>, or in <command>mac-fdisk</command> using the
<userinput>b</userinput> command.

</para><para>

The special partition type Apple_Bootstrap is required to prevent
MacOS from mounting and damaging the bootstrap partition, as there are
special modifications made to it in order for OpenFirmware to boot it
automatically.

</para><para>

Note that the bootstrap partition is only meant to hold 3 very small
files: the <command>yaboot</command> binary, its configuration
<filename>yaboot.conf</filename>, and a first stage OpenFirmware
loader <command>ofboot.b</command>.  It need not and must not be
mounted on your file system nor have kernels or anything else copied
to it. The <command>ybin</command> and <command>mkofboot</command>
utilities are used to manipulate this partition.

</para><para>

In order for OpenFirmware to automatically boot &debian; the bootstrap
partition should appear before other boot partitions on the disk,
especially MacOS boot partitions.  The bootstrap partition should be
the first one you create. However, if you add a bootstrap partition
later, you can use <command>mac-fdisk</command>'s
<userinput>r</userinput> command to reorder the partition map so the
bootstrap partition comes right after the map (which is always
partition 1). It's the logical map order, not the physical address
order, that counts.

</para><para>

Apple disks normally have several small driver partitions. If you
intend to dual boot your machine with MacOSX, you should retain these
partitions and a small HFS partition (800k is the minimum size). That
is because MacOSX, on every boot, offers to initialize any disks which do
not have active MacOS partitions and driver partitions.

</para>
  </sect2>
<!--   End of file partitioning/partition/powerpc.xml -->

<!-- Start of file partitioning/partition/sparc.xml -->
<!-- $Id: sparc.xml 11648 2004-03-22 00:37:46Z joeyh $ -->


  <sect2 arch="sparc"><title>Partitioning for &arch-title;</title>
<para>

Make sure you create a <quote>Sun disk label</quote> on your boot disk.  This is
the only kind of partition scheme that the OpenBoot PROM understands,
and so it's the only scheme from which you can boot.  The
<keycap>s</keycap> key is used in <command>fdisk</command> to
create Sun disk labels.

</para><para>

Furthermore, on &arch-title; disks, make sure your first partition on
your boot disk starts at cylinder 0.  While this is required, it also
means that the first partition will contain the partition table and
the boot block, which are the first two sectors of the disk.  You must
<emphasis>not</emphasis> put swap on the first partition of the boot
drive, since swap partitions do not preserve the first few sectors of
the partition.  You can put Ext2 or UFS partitions there; these will
leave the partition table and the boot block alone.

</para><para>

It is also advised that the third partition should be of type <quote>Whole
disk</quote> (type 5), and contain the entire disk (from the first cylinder
to the last).  This is simply a convention of Sun disk labels, and
helps the <command>SILO</command> boot loader keep its bearings.

</para>
  </sect2>
<!--   End of file partitioning/partition/sparc.xml -->

 </sect1>
<!--   End of file partitioning/partition-programs.xml -->

</appendix>
<!--   End of file partitioning/partitioning.xml -->
